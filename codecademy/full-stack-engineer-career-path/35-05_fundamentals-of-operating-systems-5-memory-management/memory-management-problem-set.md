What is the difference between these three types of memory - disk, main memory, process registers?

- Registers are the closest form of memory to the processor. They contain the actual values that the processor uses to execute its operations. Though it is the fastest form of memory, it is also the most scarce — less information can be stored in process registers than in any other location in memory. On the opposite end of the spectrum is disk. It is the slowest form of memory (the furthest from the processor) but the type of memory which it has the most of. Disk is deep storage for our computers. Main memory is the middle ground between the two; it is faster than disk but slower than registers and lies between those two extremes also in terms of how much information we can store there. Information which the processor will need soon but not at this exact moment is typically stored in main memory.

How does the memory management technique paging work?

- The fundamental problem paging solves is that computer infrastructure dictates that, from a process’ perspective, it must appear that its memory is stored contiguously. Because processes vary in the amount of memory they need though, if we store the data contiguously in physical memory (segmentation) we run into the fragmentation problem. Paging solves this problem. Using paging, the physical address space is split up into equal-sized blocks of memory called pages. Each process is allocated a certain number of contiguous pages of virtual memory. Processes use this virtual memory just as they would physical memory. The trick is that, with paging, contiguous pages of virtual memory can map to non-contiguous pages in physical memory. Therefore, every time a block of memory is freed or allocated, it will be a page-sized block — thus avoiding the fragmentation problem.

How does using virtual memory make our OS more secure?

- Virtual memory allows the OS to sandbox user-space processes. What this means is that the OS can allocate a certain amount of memory to a given process and have it appear to that process as though that memory is all the memory that exists. The alternative to using virtual memory is to let processes directly access physical memory. This, however, risks compromising our entire computer system. A process with direct access to physical memory could allocate an indefinite amount of memory. It could, therefore, overwrite other processes’ memory and, by doing so, seize control of our computer.

How does fragmentation occur and why is it a problem?

- Using segmentation, a process’ data is stored in a single contiguous block of physical memory. Fragmentation is a term which describes the tendency for gaps of free memory between those blocks to become larger and larger over time. This happens because our OS cannot anticipate the future memory needs of our processes. For example, if the OS needs to allocate 100 bytes, and has two locations to allocate it at — either a free block of 500 or 300 bytes, it may decide to allocate it at the 500 byte block. But now, when a process requests 500 bytes, its memory has nowhere to go even though there are 700 free bytes. It must now wait for more memory to be freed before its memory can be allocated. Having to wait for memory in this scenario is extremely inefficient, which is why more efficient memory management techniques have been created.

What is the difference between dynamic and static loading?

- When we ask our computer to run a certain process, it requires some information so that it may do so successfully. This information in memory is fetched during the loading phase of process initialization and execution. Dynamic and static loading take opposite approaches to loading. Using static loading, the entirety of the information necessary to run a program is loaded in memory once (at runtime); no information is ever loaded after that point. On the other hand, using dynamic loading, only the information necessary to run a program at a given moment is loaded; so if a process only needs a value at the very end of execution, that is when it will be loaded. Performance-wise, static loading sacrifices more time loading upfront and overall higher memory usage, but makes up for it with faster runtimes. Dynamically-loaded processes are quick to start and use up less memory, but have slower run times since each new piece of information has to be fetched from disk before the process can continue.
